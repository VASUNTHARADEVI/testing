/**
 * Copyright (c) 2012 Yahoo! Inc. All rights reserved.
 *
 *  Version Manifest is a build script used to process and version static assets including CSS and JS. 
 *  This allows production files to be versioned and staged for deployment. JS and CSS files can also 
 *  be combined and/or minified. The resulting asset URLs are written to a definition.js file in order 
 *  to access local or production paths depending on your environment.
 */

var fileSystem   = require('fs');
var childProcess = require('child_process');
// https://github.com/mishoo/UglifyJS
var jsparse = require("uglify-js").parser;
var jsmin = require('uglify-js').uglify;
// https://github.com/jbleuzen/node-cssmin
var cssmin = require('cssmin').cssmin;

var VersionManifest = function (root, paths, options) { 
    this.devEnv = 'asset_mode:dev';
    this.master = 'asset_mode:prod';
    this.root   = root;
    this.paths  = paths;

    this._options = options || {};
    /*
     * var _revisions - used to store svn revisions for CSS and JS files
     */
    this._revisions = {};
    /*
     * var _filesInfo - used to store the required information about CSS & JS files
     */
    this._filesInfo = {};
     /*
      * var _files - used to store all collected CSS and JS file paths in a root directory  
      */
    this._files = [];
};

VersionManifest.prototype.constructor = VersionManifest;

/**
 *  This function collects all asset files in a given directory and fetchs
 *  the latest svn revision numbers for each asset file in the directory.
 *  It takes a callback function and executes it by passing the collected files
 *
 *  @parma - callback
 */
VersionManifest.prototype.getFiles = function (cb) {
    var that = this,
        prefix = this.getFilePrefix();

    this.readDir(this.root, this.paths);
    this.getRevision(function() {
        var i, il,
            directives, rev;
            filesInfo = that.getFileInfo();
        
        for (i=0, il = that._files.length; i < il; i++)
        {
            file = that._files[i];
            rev = that._revisions[file];
            directives = that.parseDirectives(file);
            if(filesInfo.hasOwnProperty(file)){
                if (that.array_key_exists('use_local_path', directives)) {
                    filesInfo[file].remote = filesInfo[file].local;
                } else {
                    filesInfo[file].remote = that.getRemotePath(filesInfo[file], rev);
                }
                filesInfo[file].rev = rev;
                filesInfo[file].comment = filesInfo[file].filename + ' ' + rev;
            }
        }
        
        that.processRollups();
        cb(filesInfo);
    });
};
    
/**
 *  This functions allows to commit the definition.json file into SVN generated by the VM
 *  
 *  @param filename - the generated/updated definition.json file
 *  @param bugNumber - the bug number used to commit the file into the svn
 *  @param msg - optional svn commit msg
 *  @param callback - optional callback function  
 */
VersionManifest.prototype.commit = function(filename, bugNumber, msg, cb) {
    var message = bugNumber ? '[bug ' + bugNumber + '] ' : '' + (msg || 'Update assets config'),
        cmd = 'svn commit -m "' + message + '" ' + filename;
    
    childProcess.exec(cmd, function(error, stdout, stderr){
        if (error) {
            console.log(cmd + "\n" + 'ERROR: SVN commit failed ' +  output);
        }
        return cb(cmd + "\n" + stdout);
    });
};


/**
 *  Write versioned files to specified path
 *
 *  @param destination - the destination path where the files will be written to
 *  @parm files - procssed asste files  
 */
VersionManifest.prototype.stageFiles = function (destination, files) {
    var messages      = [],
        minify        = this.getOption('minify'),
        replaceAssets = this.getOption('replaceAssets'),
        remotePrefix  = this.getOption('remotePrefix'),
        destination   = this.appendSlash(destination);

    // gather file replacements if enabled
    assetPathsLocal  = [];
    assetPathsRemote = [];
    if (replaceAssets){
        for (var file in files) {
            if (!files.hasOwnProperty(file)) {
                continue;
            }
            assetPathsLocal.push(files[file].local);
            assetPathsRemote.push(files[file].remote);
        }
    }

    for (var file in files) {
        if (!files.hasOwnProperty(file)) {
            continue;
        }

        // skip files contributing into rollups and local only files
        var fileInfo = files[file];
        var opts     = fileInfo.hasOwnProperty('opts') ? fileInfo.opts : {};
        if (opts.hasOwnProperty('rollup_path') || this.array_key_exists('use_local_path', opts)){
            continue;
        }

        // it's a rollup if the content key is set so handle it differently
        var isTempFile = false;
        if (fileInfo.hasOwnProperty('content')){
            // create a temp file if we need to minify
            if (minify) {
                isTempFile = true;

                var generateName = function(rawAffixes, defaultPrefix) {
                    var now = new Date();
                    var name = [rawAffixes,
                                now.getYear(), now.getMonth(), now.getDay(),
                                '-',
                                process.pid,
                                '-',
                                (Math.random() * 0x100000000 + 1).toString(36),
                                ''].join('');
                    return path.join(exports.dir, name);
                }
                var srcFile = generateName(destination, 'vm');
                this.writeToFile(srcFile, data);
            }
        } else { // otherwise grab data from the existing file
            srcFile = file;
            try {
                data = fileSystem.readFileSync(srcFile);
            } catch (ex) {
                console.log(ex.message);
                continue;
            }
        }
        
        var regex = new RegExp(remotePrefix);
        var remote = (fileInfo.remote || '').replace(regex, '');
        var destFile = destination + remote.substr(1);

        msg = destFile + ': ';
        ext = fileInfo.ext;
        
        // replace asset paths
        if ('css' === ext || 'js' === ext)
        {
            // convert buffer to string before further processing
            data = data.toString();
            
            if(minify)
            {
                if(ext === 'js')
                {
                    data = jsmin.gen_code(jsmin.ast_squeeze(jsmin.ast_mangle(jsparse.parse(data))));
                } else {
                    data = cssmin(data);
                }
                
                // newline is used to separate files in a combo
                data = '\n' + (fileInfo.comment ? '/* ' + fileInfo.comment + ' */ ' : '') + data;
            }
            
            if(replaceAssets)
            {
                for (var i = 0, il = assetPathsLocal.length; i<il; i++) {
                    data = data.replace(assetPathsLocal[i], assetPathsRemote[i]);
                }
            }
        }

        msg += 'written';
        messages.push(msg);

        var dir = destFile.substr(0, destFile.lastIndexOf('/'));
        this.mkdirP(dir); 
        this.writeToFile(destFile, data);
    }
    return messages.join("\n");
};

/**
 *  This function collects all CSS & JS files in a given path
 *  
 *  @param root - the root directory
 *  @param paths - list of directories to process within the root directory  
 */
VersionManifest.prototype.readDir = function (root, paths) {
    var includePattern = this.getOption('includePattern', '\.(js|css|png|gif|jpg)$'),
        excludePattern = this.getOption('excludePattern');
        
    // Collect files recursively from under srcroot
    root = this.appendSlash(root);
    for (var i=0; i < paths.length ; i++){
        dir = this.appendSlash(root + paths[i]);
        this.addFiles(this.collectFiles(dir, includePattern, excludePattern));
    }
};
    
/**
 *  This function allows to extract an element from the options using a key.
 *
 *  @param name - a hash key to access the associative array/options
 *  @param defaultValue - optional default value to be returned when unable to find the element in the array
 */
VersionManifest.prototype.getOption = function (name, defaultVal) {
    if (undefined != this._options[name]){
        return this._options[name];
    }
    return defaultVal || '';
};
    
/**
 *  This function removes the trailing slash from a path
 *  
 *  @param path
 */
VersionManifest.prototype.appendSlash = function (path) {
    if (undefined != path && path.lastIndexOf('/') == path.length-1) {
        return path; 
    }  
    return path + '/';
};

/**
 *  Collects files recursively under a given dir that match a specified pattern
 *
 *  @param dir - the directory where the files are get collected from
 *  @param pattern - optional pattern used to match the required directories/files
 *  @param excludePattern - optional pattern used to execluded unwanted files or directories 
 */
VersionManifest.prototype.collectFiles = function (dir, includePattern, excludePattern) {

    var collected = [],
        files     = [],
        file,
        incRegex = includePattern ? new RegExp(includePattern) : null,
        excRegex = excludePattern ? new RegExp(excludePattern) : null,
        include,
        exclude,
        isDir;
    
    try {
        files = fileSystem.readdirSync(dir);
    } catch(e) {
        console.log(e.message);
        return collected;
    }
    
    for (var i=0; i < files.length; i++)
    {
        file = files[i];
        
        // Skip ., .., .svn folders
        if (file === '.' || file === '..' || file === '.svn') {
            continue; 
        }
        
        // prepend dir
        file = dir + file;
        
        // test if dir
        isDir = false;
        try {
            stats = fileSystem.statSync(file);
            isDir = stats.isDirectory() ? true : false;
        } catch(e) {
            console.log(e.message);
            continue;
        }
        
        // if dir append slash before testing include
        if (isDir){ file += '/'; }
        
        // determine if the file should be included
        exclude = excRegex ? excRegex.test(file) : false;
        include = !exclude && (incRegex && !isDir ? incRegex.test(file) : true);
        
        if(include){
            if(isDir && !exclude){
                collected = collected.concat(this.collectFiles(file, includePattern, excludePattern));
            } else {
                try {
                    file = fileSystem.realpathSync(file);
                } catch (ex) {
                    console.log(e.message);
                    continue;
                }
                
                if (!this.in_array(file, collected)) {
                    //console.log('Including: ', file)
                    collected.push(file);
                }
            }
        } //else { console.log('Excluding: ', file); }
    }
    
    return collected;
};

/**
 *  This function is used to merge files into the member property _files
 *
 *  @param files - new list/array of files to be added
 *  @return _files - merged files 
 */
VersionManifest.prototype.addFiles = function (files) {
    if (undefined != files && typeof(files) == 'object' && files.length){
        for (var i=0; i < files.length; i++) {
            if (files[i] && !this.in_array(files[i], this._files)) {
                this._files.push(files[i]);
            }
        }
    }
    return this._files;
};
    
/**
 *  This function is used to get the basic required file information for VM
 *  
 *  @return files - it returns array of fileinfos
 */
VersionManifest.prototype.getFileInfo = function() {
    var files  = {},
        prefix = this.getFilePrefix(),
        type   = this.getOption('projectType');
    
    for (var i=0; i < this._files.length; i++)
    {
        var file = this._files[i];
        
        // will be undefined if excluded in collectFiles
        if(typeof file === 'undefined'){ continue; }
        
        var directives = this.parseDirectives(file);
        // don't store the file if the skip directive was found
        if  (this.array_key_exists('skip', directives)){
             continue;
        }
        
        var filename   = file.substr(file.lastIndexOf('/')+1);
        var basename   = this.stripFileExtension(filename);
        var extension  = this.getFileExtension(filename);
        
        // prefixFile used to modify the prefix on each file
        // TODO: reassess this option for mojito
        //var prefixName = prefix;
        if (directives.hasOwnProperty('generic_project_name')) {
            var mojitName = this.getOption('mojitName');
            //prefixName = prefix.replace(mojitName, directives.generic_project_name) + prefix;
        }
        
        // paths
        var group = this.getOption('group'),
            rootPath = type === 'mojit' ? '/' + this.getOption('mojitName') + '/' : 'mojits/',
            basePath = file.substr(file.indexOf(rootPath) + rootPath.length),
            localPath,
            local,
            match,
            name,
            regex;

        if(type === 'app')
        {
            regex = new RegExp('/((?:' + this.paths.join('|').replace('./', '') + ')/.+$)');
            match = basePath.match(regex);
        }
        else if(type === 'mojit')
        {
            // setting match as a two element array for consistency
            match = [null, basePath.replace('/' + group + '/', '/')];
        }
        else
        {
            if(basename.match(/\/controller\./)){
                match = basePath.match(/([^/]+\/controller\..+)/);
            } else {
                match = basePath.match(/\/([^/]+\/(?:assets|autoload|models|binders)\/.+$)/);
            }
        }
        
        if(match){
            local = prefix + match[1];
        } else {
            continue;
        }
        
        // generic_name
        if (directives.hasOwnProperty('generic_name')) {
            name = directives.generic_name.match('/') ? directives.generic_name : local.replace(basename, directives.generic_name);
        } else {
            name = local;
        }

        var fileSize;
        try {
            stats    = fileSystem.statSync(file);
            fileSize = stats.size; 
        } catch (ex) {
            fileSize = 'unknown';
        }
            
        files[file] = {
            'name'     : name,
            'filename' : filename,
            'path'     : file,
            'ext'      : extension,
            'opts'     : directives,
            'local'    : local,
            'size'     : fileSize
        };
    }
    
    //console.log(files)
    return files;
};

/**
 * Extract the revision number of a file and executes a callback function
 * 
 * @return  returns the callback results
 */
VersionManifest.prototype.getRevision = function (cb) {
    var self  = this,
        files = self._files.join(' '),
        cmd   = 'svn status --xml --verbose ' + files,
        exec  = childProcess.exec;
    
    if(files.length === 0){ return cb(); }
    
    exec(cmd, function (error, stdout, stderr)
    {
        if (error) {
            console.log('ERROR: unable to exec cmd: `' + cmd, '`, ', error.message);
            return false;
        }
        
        // remove new lines from xml and split into individual targets
        var regex = /<target +path="([^"]+)">.+<commit +revision="([0-9]+)">/,
            targets = stdout.replace(/\n/g, ' ').split('</target>'),
            matches,
            t, tl;
        
        // pop off the last piece of closing xml and iterate
        targets.pop();
        for(t=0, tl=targets.length; t<tl; t++)
        {
            matches = regex.exec(targets[t]);
            if(matches){
                self._revisions[matches[1]] = matches[2];
            }
        }
        
        return cb();
    });
};

/** 
 *  Parses the directives from CSS and JS files
 *
 *  @param path - the CSS or JS path
 *  @return directives - array of directives
 */
VersionManifest.prototype.parseDirectives = function (path) {
    var directives = {};
    try { 
        var content = fileSystem.readFileSync(path);
        content.toString().replace(/(?:[ \t\*\#]+)?@vm[ \t]+([a-zA-z_-]+):?(?:[ \t]+)?([^ \t\n\r]+)?/g, function(m, key, value){
        if (directives.hasOwnProperty(key)) {
            // if we already have a directive with this key
            // and its a string then change it into an array
            if (directives[key].substr){
                directives[key] = [directives[key]];
            }
            directives[key].push(value || '');
        } else {
            directives[key] = value || '';
        }
        });
    } catch (e) { console.log(e.message); }

    return directives;
};

/**
 *  Strips out the file exension
 *
 *  @param file - the filename
 *  @return file - the filename without the ext
 */
VersionManifest.prototype.stripFileExtension = function (file) {
    return file.substr(0, file.lastIndexOf('.'));
};
    
/**
 *  It replaces directory strings: mojits to m, projects to p or removes assets, js, css directories
 *
 *  @params file
 *  @return file - the treated file name
 */
VersionManifest.prototype.shortenPath = function (file) {
        file = file.replace('\/mojits\/','/j/');
        file = file.replace('\/addons\/', '/n/');
        file = file.replace('\/autoload\/', '/a/');
        file = file.replace('\/binders\/', '/b/');
        file = file.replace('\/lib\/', '/l/');
        file = file.replace('\/models\/', '/m/');
        file = file.replace('\/assets\/', '/');
        file = file.replace('\/images\/', '/');
        file = file.replace('\/js\/', '/');
        file = file.replace('\/css\/', '/');
        file = file.replace(this.getOption('localPrefix'), '');
        return file;
    };

/**
 *  Gets the file extension
 *
 *  @param file - the file name
 *  @return ext - returns the extension
 */
VersionManifest.prototype.getFileExtension = function (file) {
    var lastIndexOf = file.lastIndexOf('.'); 
    if (lastIndexOf > 0) {
        var ext = file.substr(lastIndexOf+1);
        return ext.toLowerCase();
    } 
    return '';
};
    
/**
 *  File prefix for the remote files
 * 
 *  @return prefix 
 */
VersionManifest.prototype.getFilePrefix = function (includeExtras) {
    var group = this.getOption('group'),
        localPath = this.getOption('localPrefix'),
        isMojit = this.getOption('projectType') === 'mojit',
        typePath = includeExtras && isMojit ? 'mojits/' : '';
    
    return localPath + '/' + typePath + (group && includeExtras ? group + '/' : '') + (isMojit && !this.getOption('appLevel') ? this.getOption('mojitName') + '/' : '');
};

/**
 *  Checks if the given key or index exists in the array
 *
 *  @param key - value to check
 *  @param search - an array with keys to check
 * 
 *  @return true/false
 */
VersionManifest.prototype.array_key_exists = function (key, search) {
    if (!search || (search.constructor !== Array && search.constructor !== Object)) {
        return false;
    }
    return key in search;
};

/**
 *  Extracts the max svn revision number
 *
 *  @param revisions - an array of revisions
 *  @return maxVal - the max revision number in the array of revisions 
 */
VersionManifest.prototype.max = function (revisions) {
    var maxVal = '';
    for (var i = 0; i < revisions.length; i++) {
        if (revisions[i] >= maxVal) {
            maxVal = revisions[i]; 
        }
    }
    return maxVal;
};

/**
 *   Builds a remote path
 * 
 *   @param file - the css or js filename
 *   @param rev - the svn revision number of the css or js filename
 */
VersionManifest.prototype.getRemotePath = function (file, rev) {
    var ext          = this.getFileExtension(file.filename),
        minify       = this.getOption('minify') ? '-min' : '',
        remotePrefix = this.getOption('remotePrefix'),
        type         = this.getOption('projectType'),
        relFile;
    
    if(type === 'mojit')
    {
        var mojitPath = '/' + this.getOption('mojitName') + '/',
            mojitRoot = file.path.indexOf(mojitPath) + mojitPath.length;
        
        relFile = this.getFilePrefix(true) + file.path.substr(mojitRoot);
    }
    else
    {
        relFile = file.local;
    }
    
    rev = undefined != rev ? '-' + rev : '';  
    return remotePrefix + this.shortenPath(this.stripFileExtension(relFile)) + minify + rev + '.' + ext;
};
    
/**
 *  Rollups Css or JS files into a single file
 */
VersionManifest.prototype.processRollups = function () {
    var comment = '',
        rollup  = [];
        rollups = [];
        
    // gather and group all files with rollups
    for (var i=0; i < this._files.length; i++) {
        var file = this._files[i];
        if (!file || !this._filesInfo.hasOwnProperty(file)) {
            continue;
        }
        var fileInfo = this._filesInfo[file];
        var opts     = this._filesInfo[file].opts;
        var path = opts.rollup_path || '';
        if (path){
            if (!rollups.hasOwnProperty(path)) {
                rollups[path] = {};
                rollups[path].files = [];
            }
            rollups[path].files.push({
                'name'  : fileInfo.path,
                'order' : opts.rollup_order || ''
            });
            rollups[path].rev = max([fileInfo.rev, rollups[path].rev] || []);
            comment += (comment ? '; ' : '') + fileInfo.filename + ' ' + file.rev;
        }
    }

    // get the content of the files in each rollup and build final path string
    for (var path in rollups) {
        var end     = [], content = [];
        if (!rollups.hasOwnProperty(path)) {
            continue;
        }
        rollup = rollups[path];
        for (var file in rollup.files) {
            if (!rollups.hasOwnProperty(file)) {
                continue;
            }
            fileName = file.path;
            fileInfo = this._filesInfo[fileName];
            try {
                fileContent = fileSystem.readFileSync(fileInfo[path]);
            } catch (ex) {
                console.log(ex.message);
                continue;
            }

            // handle ordering if specified
            index = file.order || false;
            if (false !== index){
                // try not to clobber if a duplicate order was provided
                while (undefined != content[index]){
                    index++;
                }
                content[index] = fileContent;
            } else { // otherwise push content to the end
                end.push(fileContent);
            }
        }

        // sort and build a final string
        content = content.concat(end);
        content = content.join("\n");
        // push staging info to the files array
        fullPath = this.getFilePrefix() + path;
        filesInfo[path] = {
                'ext'      : this.getFileExtension(path),
                'name'     : fullPath,
                'path'     : path + ' (rollup)',
                'remote'   : this.getRemotePath(filesInfo[file], rollup.rev),
                'content'  : content,
                'comment'  : comment,
                'filename' : path.substr(path.lastIndexOf('/')+1),
                'rev'      : rollup.rev,
                'opts'     : {'rollup' : true} // this will cause it to be omitted from final YCB
        };
    }
};

/**
  *  Creates a directory recursively
  *
  *  @param path 
  */
VersionManifest.prototype.mkdirP = function(path){
    var pathSegments= path.split("/");
    if ('' == pathSegments[0]) {
        pathSegments= pathSegments.slice(1);
    }
    for (var i=0; i <= pathSegments.length; i++) {
        var pathSegment = '/' + pathSegments.slice(0,i).join("/");
        try {
            fileSystem.statSync(pathSegment);
        } catch(ex) {
            try {
                fileSystem.mkdirSync(pathSegment, 0755);
            } catch(e) {
                console.log(e.message);
                return;
            }
        }
    }
};

/**
 *  Util function to create a list of path entries for definision.json
 *
 * @param path - the real CSS/JS path
 * @param type - CSS/JS
 */
VersionManifest.prototype.createConfigEntry = function(path, type) {
    var entry = {
        path: path,
        type: type
    };
    return entry;
};

/**
 *  Utils function used to build the definition.json file
 * 
 *  @param filename - VM cmd line output file or the deninition.json file 
 *  @param files - list of JS/CSS files
 *  @return mergedConfigData 
 */
VersionManifest.prototype.buildConfigData = function (filename, files) {
    var config = {};
        dir    = '';
    
    if(!config[this.master]) {
        config[this.master] = {};
    }
    
    if(!config[this.devEnv]) {
        config[this.devEnv] = {};
    }
    
    for (var file in files) {
        if (!files.hasOwnProperty(file)) {
            continue;
        }
        var fileInfo = files[file];
        var opts     = fileInfo.opts || {};
        // skip rollups and images if not explicitly enabled
        if (opts.rollup){
            continue;
        }
            
        // handle the remote path for rollups
        rollup = opts.rollup_path || false;
        if (rollup && files[rollup]) {
            remote =  files[rollup].remote;
        } else {
            remote = fileInfo.remote;
        }
        
        var name = fileInfo.name;
        if (opts.dimensions){
            dimensions = opts.dimensions.substr ? [opts.dimensions] : opts.dimensions;
            
            if(!config.master) {
                config.master = {};
            }
            config.master[name] = this.createConfigEntry('', fileInfo.ext);
            
            for (var i=0; i < dimensions.length; i++) {
                var dimension = dimensions[i].replace(/=/g, ':').replace(/&/g, ',').replace(/ +/g, '');
                
                if (typeof config[dimension] === "undefined") {
                    config[dimension] = {};
                }
                
                if(fileInfo.remote !== '')
                {
                    // push prod version
                    config[dimension][name] = this.createConfigEntry(fileInfo.remote, fileInfo.ext);
                    
                    // push dev version
                    var devDims = [this.devEnv, dimension];
                    devDims.sort();
                    devDims = devDims.join(',');
                    
                    if(!config[devDims]) {
                        config[devDims] = {};
                    }
                    config[devDims][name] = this.createConfigEntry(fileInfo.local, fileInfo.ext);
                }
            }
        } else {
            config[this.devEnv][name] = this.createConfigEntry(fileInfo.local, fileInfo.ext);
            config[this.master][name] = this.createConfigEntry(fileInfo.remote, fileInfo.ext);
        }

        dir = file.substr(0, file.lastIndexOf('/assets/')+1);
    }

    return this.mergeDefConfigData(filename, config);
};

/**
 *  Util functions to merge the definition.json data
 * 
 *  @param filename - VM cmd line outfile 
 *  @param config - the definition.json config data
 *  @return configData 
 */
VersionManifest.prototype.mergeDefConfigData = function (filename, config) {
    var finalConf = [],
        finalConfDimIndices = {};

    try {
        var confData = fileSystem.readFileSync(filename);
        confData = JSON.parse(confData.toString()); 
    } catch (e) { console.log(e.message); }

    if (confData && confData.length) {
        for (var i=0; i < confData.length; i++) {
            var entry    = confData[i];
            var settings = entry.settings || [];
            
            // turn settings array into a string for easy comparison
            // TODO: create convenience method
            settings.sort();
            entry.settings = settings.join(',');
            
            // get rid of the old assets
            delete entry.assets;
            
            // add the entry to the new set of data if it's not empty
            // it's not empty if it contains more than the settings key
            for(var key in entry){
                if(entry.hasOwnProperty(key) && key !== 'settings'){
                    finalConf.push(entry);
                    finalConfDimIndices[settings] = finalConf.length - 1;
                    break;
                }
            }
        }
    }
    
    // push all assets to new config
    for (var dim in config) {
        i = finalConfDimIndices[dim]
        assets = config[dim];
        if (typeof i !== 'undefined'){
            finalConf[i].assets = config[dim];
        } else {
            finalConf.push({
                'settings': dim,
                'assets': config[dim]
            });
        }
    }
    
    // turn each settings back into an array
    for (var i=0; i < finalConf.length; i++) {
        finalConf[i].settings = finalConf[i].settings.split(',');
    }

    finalConf = JSON.stringify(finalConf, null, '    ');
    if (undefined == filename) {
        this.writeToFile(filename, finalConf);
    }
    return finalConf;
};

/**
 * Checks if the given value exists in the array
 *
 * @param neele
 * @para haystack
 * @return true/false 
 */ 
VersionManifest.prototype.in_array = function (needle, haystack) {
    for (key in haystack) {
        if (haystack[key] === needle) {
            return true;
        }
    }
    return false;
};

/**
 *  Util function used for writing data into a given file
 *
 *  @param filename 
 *  @param data 
 */
VersionManifest.prototype.writeToFile = function (file, data) {
    try { 
        fileSystem.writeFileSync(file, data);
    } catch (ex) {
        console.log(ex.message);
    }
};
    
/**
 *  This function generates the definition.json files
 *
 *  @param filename - output filename taken from the VM cmd line
 *  @param files - array of js/css files
 */
VersionManifest.prototype.save = function (filename, files, dryrun) {
    var configData = this.buildConfigData(filename,files); 
    if (undefined != filename && !dryrun) {
        this.writeToFile(filename, configData);
    }
    return configData;
};

exports.VersionManifest = VersionManifest;

