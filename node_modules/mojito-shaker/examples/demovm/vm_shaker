#!/usr/bin/env node

var program    = require('commander'),
    fileSystem = require('fs'),
    vm         = require('./VersionManifest.js'),
    SHAKER = {count: 2, meta: { dimensions: {common: {include:[]} }, actions: {}}};

program
  .version('0.0.1')
  .option('-a, --replaceassets', 'Replace image paths within CSS and JS assets.')
  .option('-b, --bug <num>', 'The bug number to use when committing to so svn.')
  .option('-c, --commit', 'Commit the updated manifest into svn')
  .option('-d, --dryrun', 'Perform a dry run without writing the manifest')
  .option('-f, --folders <dir>', 'Folders which contain assets. This option can be specified multiple times.')
  .option('-g, --group <name>', 'The mojit group.')
  .option('-i, --includepattern <regex>', 'Regular expression to match files to include. Default is to include js and css files.')
  .option('-l, --localpath <path>', 'A path that will be prepended to the local files referenced in the manifest.', '/static')
  .option('-m, --minify', 'Minify the staged files.')
  .option('-n, --projectname <name>', 'Mojit or app name.')
  .option('-o, --file <file>', 'Where to output the manifest file. Default is mojits/<group-name>/<mojit-name>/definition.json or application.json')
  .option('-r, --remotepath <path>', 'A domain and path that will be prepended to the remote files referenced in the manifest.')
  .option('-s, --srcroot <dir>', 'Root directory where your source files reside. Default is "mojits/<group-name>/<mojit-name>/assets" or "./" for app.')
  .option('--shaker', 'Generate shaker.json files to get VM working with Shaker.')
  .option('-t, --type <type>', 'The project type, "mojit", "app", or "all". Default is "mojit".')
  .option('-v, --verbose', 'Display more information while generating the manifest.')
  .option('-w, --writepath <path>', 'Path to write versioned files to.')
  .option('-x, --excludepattern <regex>', 'Regular expression to match files to exclude.', 'artifacts|tests|\\.server\\.')

program.on('--help', function(){
  console.log('  Examples:');
  console.log('      $ version_manifest -n chrome -r http://l.yimg.com/os/mit/zed -w /tmp/ -a -m -v');
  console.log('      $ version_manifest -g page -n page_frame -r http://l.yimg.com/os/mit/zed -w /tmp/ -a -m -v');
  console.log('      $ version_manifest -t app -r http://l.yimg.com/os/mit/zed -w /tmp/ -a -m -v');
  console.log('      $ version_manifest -t all -r http://l.yimg.com/os/mit/zed -w /tmp/ -a -m -v');
  console.log('');
  console.log('      $ version_manifest --help');
  console.log('');
});

program.parse(process.argv);

if (undefined != program.bug && !(/^\d+$/.test(program.bug))) {  
   console.log('Bug number (' + program.bug + ') must be numeric.');
}

if (undefined == program.type) {  
   program.type = 'mojit';
}

if (program.type === 'mojit' && undefined == program.projectname) {  
   console.log('Required parameter -n <name> is missing.');
}

if ('all' == program.type) {
    if (program.verbose){
        console.log('INFO Preparing to version app and mojits...');
    }
    
    // execute for app
    execute(merge(program, {type:'app'}));
    
    // collect mojits
    var manifest = new vm.VersionManifest(),
        files = manifest.collectFiles('./mojits/', 'definition\\.json'),
        regex = /\/mojits(?:\/([^\/]+))?\/([^\/]+)\/definition.json/,
        match;
    
    // execute each mojit
    for(f = 0, fl = files.length; f<fl; f++)
    {
        file = files[f];
        match = file.match(regex);
        if(match){
            execute(merge(program, {type: 'mojit', group: match[1], projectname: match[2]}));
        }
    }
} else {
    execute(program);
}


function merge() {
    var a,
        al,
        final = {},
        obj,
        prop;
    
    for(a = 0, al = arguments.length; a<al; a++){
        obj = arguments[a];
        for(prop in obj){
            if(obj.hasOwnProperty(prop)){
                final[prop] = obj[prop];
            }
        }
    }
    
    return final;
}

function execute(program) {
    var manifest,
        uncommited,
        foundDirs = false,
        dir,
        dirs = [];
    
    if (undefined == program.file) {
        if(program.type === 'mojit'){
            program.file = './mojits/' + (program.group ? program.group + '/' : '') + program.projectname + '/definition.json';
        } else {
            program.file = './application.json';
        }
    }
    
    if (undefined == program.folders) {
        if(program.type === 'mojit'){
            program.folders = '';
        } else {
            program.folders = 'assets addons lib autoload models';
        }
    }
    
    if (undefined == program.srcroot) {
        if(program.type === 'mojit'){
            program.srcroot = './mojits/' + (program.group ? program.group + '/' : '') + program.projectname + '/';
        } else {
            program.srcroot = './';
            //program.excludepattern += '|/mojits/';
        }
    }
    
    // determine if mojit is appLevel
    if(program.type === 'mojit'){
        try {
            var def = JSON.parse(fileSystem.readFileSync(program.srcroot + 'definition.json')) || {};
            if(def[0] && def[0].appLevel){
                program.applevel = true;
            }
        } catch(e) {}
    }

    try {
        stats = fileSystem.statSync(program.srcroot);
        if (!stats.isDirectory()) {
            throw('Value of -s (' + program.srcroot + ') is not a directory.');
        }

        program.folders = program.folders.split(/[ \t]+/);
        for (var i=0; i < program.folders.length; i++) {
             dir = program.srcroot + program.folders[i];
             try {
                 stats = fileSystem.statSync(dir);
                 if (stats.isDirectory()){
                     foundDirs = true;
                     dirs.push(program.folders[i]);
                     if(program.verbose){
                         console.log('Found ' + dir );
                     }
                 }
             } catch (e){ }
        }

        if (!foundDirs) {
            throw('No directories found.');
        }
    } catch (ex) {
        console.log(ex.message);
        throw ex; 
    }

    manifest = new vm.VersionManifest(program.srcroot, dirs, { 
        'group'          : program.group,
        'projectType'    : program.type,
        'mojitName'      : program.projectname,
        'appLevel'       : program.applevel,
        'localPrefix'    : program.localpath,
        'remotePrefix'   : program.remotepath,
        'excludePattern' : program.excludepattern,
        'replaceAssets'  : program.replaceassets,
        'outputImages'   : program.outputimages,
        'includePattern' : program.includepattern,
        'dataUriMaxBytes': program.datauris,
        'minify'         : program.minify,
        'file'           : program.file
    });

    manifest.getFiles(function(files){
       var uncommited = [],
           message,
           count = 0,
           key;

       for (key in files){
           if (files.hasOwnProperty(key)) {
               file = files[key];
               if (file['rev'] == 0) {
                   uncommited.push(file['path']);
               }
               count++;
           }
       }

       // error out if there are unrevisioned files
       if (uncommited.length > 0){
           console.log("ERROR The following files do not have an SVN revision: \n");
           console.log(uncommited.join("\n  * "));
           console.log('Exiting.');
           process.exit(1);
       }

       if(count){
           message = manifest.save(program.file, files, program.dryrun);
           if (program.verbose){
               console.log('INFO writing file ' + program.file);
               console.log(message);
           }
       } else if (program.verbose){
           message = program.type === 'app' ? 'app' : (program.group ? program.group + '/' : '') + program.projectname;
           console.log('INFO No files found for ' + message + '.');
       }
 
       if (program.dryrun){
           console.log('INFO dryrun... skipping write.');
           return;
       }

       if(program.shaker){
          shakeFiles(files, SHAKER.meta);
          if(!--SHAKER.count){
            endShake(SHAKER.meta);
          }
       }

       if (undefined != program.commit){
           var message = manifest.commit(program.file, program.bug, '', function(msg){
              if(program.verbose){ 'INFO ' + console.log(message); }
           });
       }
       
       stageFiles(files);
    });

    function stageFiles(files) {
       if (undefined != program.writepath){
           if (program.verbose){
               console.log('INFO copying' + ( program.minify ? ' and minifying' : '' ) + ' files...');
           }
           var message = manifest.stageFiles(program.writepath, files);
           if (program.verbose){
               console.log(message);
           }
       }
    }
}

function shakeFiles (files,shakerObj) {
  var fileObj, filepath, dimItem, dim, pair, shaker = shakerObj;

  //console.log(JSON.stringify(files,null,'\t'));
  for(filepath in files){
      fileObj = files[filepath];
      if(fileObj.ext === 'css'){
          if(fileObj.opts.dimensions){
            //console.log(fileObj.opts.dimensions);
              if(typeof fileObj.opts.dimensions === 'string'){
                  pair = fileObj.opts.dimensions.split('=');
                  shaker.dimensions[pair[0]] = shaker.dimensions[pair[0]] || {};
                  shaker.dimensions[pair[0]][pair[1]] = shaker.dimensions[pair[0]][pair[1]] || {include: []};
                  shaker.dimensions[pair[0]][pair[1]].include.push(filepath);
              }else{
                for(dimItem in fileObj.opts.dimensions){
                  dim = fileObj.opts.dimensions[dimItem];
                  pair = dim.split('=');
                  shaker.dimensions[pair[0]] = shaker.dimensions[pair[0]] || {};
                  shaker.dimensions[pair[0]][pair[1]] = shaker.dimensions[pair[0]][pair[1]] || {include: []};
                  shaker.dimensions[pair[0]][pair[1]].include.push(filepath);
                }
              }//string vs. array

          }else{
            shaker.dimensions.common.include.push(filepath);

          }//dimensions

      }//css
  }
}

function endShake (shakerObj){
  console.log(JSON.stringify(shakerObj, null, '\t'));
}
